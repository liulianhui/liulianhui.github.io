<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vue项目中vue-layer弹框的使用]]></title>
    <url>%2F2018%2F09%2F05%2Fvue%E9%A1%B9%E7%9B%AE%E4%B8%ADvue-layer%E5%BC%B9%E6%A1%86%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[安装1npm install vue-layer 引用在程序入口添加123import Vue from &apos;vue&apos;;import layer from &apos;vue-layer&apos;Vue.prototype.$layer = layer(Vue); 全局参数重置12345import Vue from &apos;vue&apos;;import layer from &apos;vue-layer&apos;Vue.prototype.$layer = layer(Vue, &#123; msgtime: 3,//目前只有一项，即msg方法的默认消失时间，单位：秒&#125;); 参数说明1234567891011121314151617&#123; type: 0, //0（信息框，默认）1（页面层）2（iframe层）3（加载层）4（tips层） title: &apos;信息&apos;, content: &apos;&apos;, area: &apos;auto&apos;, offset: &apos;auto&apos;, icon: -1, btn: &apos;确定&apos;, time: 0, shade: true,//是否显示遮罩 yes: &apos;&apos;, cancel: &apos;&apos;, tips: [0,&#123;&#125;],//支持上右下左四个方向，通过1-4进行方向设定,可以设定tips: [1, &apos;#c00&apos;] tipsMore: false,//是否允许多个tips shadeClose: true,//点击遮罩是否关闭&#125; 调用方法123layer.alert(content, [options, yes]); // options和yes可以省略， 如果您不愿意写options，则可以直接写确定按钮的函数，即yes // content 可以为html 123layer.confirm(content, [options, yes, cancel]); // options，yes和cancel可以省略， 如果您不愿意写options，则可以直接写确定按钮的函数，即yes，或者覆盖默认的cancel方法。PS：yes和cancel方法不能互换 //content 可以为html 1234layer.msg(content, [options, end]); // options和end可以省略， 如果您不愿意写options，则可以直接写时间到期的回调即可，即end方法 // 默认msg的关闭时间为1.5秒 // content 可以为html 123layer.tips(content, follow, options);//content 可以为html//follow对css选择器，用来定位目标 123456789101112131415161718192021222324252627282930313233343536373839404142layer.iframe(&#123; content: &#123; content: componentName, //传递的组件对象 parent: this,//当前的vue对象 data:&#123;&#125;//props &#125;, area:[&apos;800px&apos;,&apos;600px&apos;], title: &apos;title&apos;&#125;);// data参数可认为是componentName的props，同时 该方法会自动添加一个key为layerid的值， 该值为创建层的id， 可以直接用来关闭该层// options参数直接写到json里即可，比如title其实使用iframe层，除了操作方便外，主要的目的是隔离代码， 降低代码复杂度。而在vue中，组件就是功能块的基本单位了，所以vue-layer中并不存在iframe的DOM元素，这里用的都是组件。 这里的content有三个参数：##### content: 此参数为组件对象， 比如 import editFrom from &apos;./edir-form.vue&apos;;此处content就为editFrom即可。##### parent:此参数其实就是当前调用layer的vue对象， 即this即可。在editForm中可以直接使用， this.$parent来获取调用layer的vue对象，然后父子传值神马的，就很easy，当然也可以直接使用vuex，就不用this.$parent了##### data: 此参数可认为是editForm的props，然后你懂得。 注： 该方法会自动添加一个key为layerid的值， 该值为创建层的id， 可以直接使用结果即为：methods:&#123; eidt() &#123; this.$layer.iframe(&#123; content: &#123; content: editForm, //传递的组件对象 parent: this,//当前的vue对象 data:&#123;&#125;//props &#125;, area:[&apos;800px&apos;,&apos;600px&apos;], title:&quot;editForm&quot; &#125;); &#125;&#125; 1layer.open(options); 1layer.close(id); 1layer.closeAll(type); 样式调整1该包的css都为vl-notice开头， 需要重写css样式，覆盖即可]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS打开设置页面及其中某指定的选项界面]]></title>
    <url>%2F2018%2F08%2F10%2FiOS%E6%89%93%E5%BC%80%E8%AE%BE%E7%BD%AE%E9%A1%B5%E9%9D%A2%E5%8F%8A%E5%85%B6%E4%B8%AD%E6%9F%90%E6%8C%87%E5%AE%9A%E7%9A%84%E9%80%89%E9%A1%B9%E7%95%8C%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[打开的代码： 123456789/** 打开设置页面或设置中某个页面 */-(void)goTAppSystem&#123; NSURL *url = [NSURL URLWithString:@&quot;prefs:root=General&quot;]; if ([[UIApplication sharedApplication] canOpenURL:url]) &#123; [[UIApplication sharedApplication] openURL:url]; &#125;&#125; 其他可用的一些参数: 1234567891011121314151617181920212223242526272829303132333435363738394041prefs:root=General&amp;path=About //关于prefs:root=General&amp;path=ACCESSIBILITY //重力感应prefs:root=AIRPLANE_MODE //飞行模式prefs:root=General&amp;path=AUTOLOCK //自动锁定prefs:root=General&amp;path=USAGE/CELLULAR_USAGE //用量prefs:root=Brightness //打开Brightness(亮度)设置界面prefs:root=Bluetooth //打开蓝牙设置prefs:root=General&amp;path=DATE_AND_TIME //日期与时间设置prefs:root=FACETIME //打开FaceTime设置prefs:root=General //打开通用设置prefs:root=General&amp;path=Keyboard //打开键盘设置prefs:root=CASTLE //打开iClound设置prefs:root=CASTLE&amp;path=STORAGE_AND_BACKUP //打开iCloud下的储存空间prefs:root=General&amp;path=INTERNATIONAL //打开通用下的语言和地区设置prefs:root=LOCATION_SERVICES //打开隐私下的定位服务prefs:root=ACCOUNT_SETTINGSprefs:root=MUSIC //打开设置下的音乐prefs:root=MUSIC&amp;path=EQ //打开音乐下的均衡器prefs:root=MUSIC&amp;path=VolumeLimit //打开音乐下的音量prefs:root=General&amp;path=Network //打开通用下的网络prefs:root=NIKE_PLUS_IPOD prefs:root=NOTES //打开设置下的备忘录设置prefs:root=NOTIFICATIONS_ID //打开设置下的通知设置prefs:root=Phone //打开电话设置prefs:root=Photos //打开设置下照片和相机设置prefs:root=General&amp;path=ManagedConfigurationList //打开通用下的描述文件prefs:root=General&amp;path=Reset //打开通用下的还原设置prefs:root=Sounds&amp;path=Ringtoneprefs:root=Safari //打开设置下的safari设置prefs:root=General&amp;path=Assistant //打开siri不成功prefs:root=Sounds //打开设置下的声音设置prefs:root=General&amp;path=SOFTWARE_UPDATE_LINK //打开通用下的软件更新prefs:root=STORE //打开通用下的iTounes Store和App Store设置prefs:root=TWITTER //打开设置下的twitter设置prefs:root=FACEBOOK //打开设置下的Facebook设置prefs:root=General&amp;path=USAGE //打开通用下的用量prefs:root=VIDEO //视频prefs:root=General&amp;path=Network/VPN //打开通用下的vpn设置prefs:root=Wallpaper //打开设置下的墙纸设置prefs:root=WIFI //打开wifi设置prefs:root=INTERNET_TETHERING]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS获取通知开启状态，并跳转到设置页面]]></title>
    <url>%2F2018%2F08%2F10%2FiOS%E8%8E%B7%E5%8F%96%E9%80%9A%E7%9F%A5%E5%BC%80%E5%90%AF%E7%8A%B6%E6%80%81%EF%BC%8C%E5%B9%B6%E8%B7%B3%E8%BD%AC%E5%88%B0%E8%AE%BE%E7%BD%AE%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[获取系统通知状态123456789101112131415161718192021/** 获取系统消息通知是否开启 @return YES为开启 NO为关闭 */- (BOOL)isUserNotificationEnable &#123; // 判断用户是否允许接收通知 BOOL isEnable = NO; if (@available(iOS 8.0, *)) &#123; // iOS版本 &gt;=8.0 处理逻辑 UIUserNotificationSettings *setting = [[UIApplication sharedApplication] currentUserNotificationSettings]; isEnable = (UIUserNotificationTypeNone == setting.types) ? NO : YES; &#125; else &#123; // iOS版本 &lt;8.0 处理逻辑 UIRemoteNotificationType type = [[UIApplication sharedApplication] enabledRemoteNotificationTypes]; isEnable = (UIRemoteNotificationTypeNone == type) ? NO : YES; &#125; return isEnable;&#125; 前往设置页面用户为开启通知，可以提示用户直接去设置页面开启通知，前往设置页面代码如下： 12345678910111213141516171819202122/** 如果用户关闭了接收通知功能，该方法可以跳转到APP设置页面进行修改 iOS版本 &gt;=8.0 处理逻辑 */- (void)goToAppSystemSetting &#123; UIApplication *application = [UIApplication sharedApplication]; NSURL *url = [NSURL URLWithString:UIApplicationOpenSettingsURLString]; if ([application canOpenURL:url]) &#123; if ([application respondsToSelector:@selector(openURL:options:completionHandler:)]) &#123; if (@available(iOS 10.0, *)) &#123; [application openURL:url options:@&#123;&#125; completionHandler:nil]; &#125; else &#123; // Fallback on earlier versions &#125; &#125; else &#123; [application openURL:url]; &#125; &#125; &#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS中UIWebView禁用放大镜、拷贝粘贴弹出框]]></title>
    <url>%2F2018%2F07%2F16%2FiOS%E4%B8%ADUIWebView%E7%A6%81%E7%94%A8%E6%94%BE%E5%A4%A7%E9%95%9C%E3%80%81%E6%8B%B7%E8%B4%9D%E7%B2%98%E8%B4%B4%E5%BC%B9%E5%87%BA%E6%A1%86%2F</url>
    <content type="text"><![CDATA[需求禁用UIWebView网页中放大镜、拷贝粘贴弹出框 方法在UIWebView网页中长按手势默认是0.5秒，添加一个自定义的长按手势 时间小于0.5秒就行，代码如下 1234567891011121314- (void)viewDidLoad &#123; [super viewDidLoad]; UILongPressGestureRecognizer *longPress = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:nil]; longPress.delegate = self; //记得在.h文件里加上&lt;UIGestureRecognizerDelegate&gt;委托 longPress.minimumPressDuration = 0.4; //小于0.5秒 [self.webView addGestureRecognizer:longPress];&#125;#pragma mark - GestureRecognizerDelegate- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer&#123; return NO; &#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WKWebView加载的网页自适应大小]]></title>
    <url>%2F2018%2F07%2F12%2FWKWebView%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%BD%91%E9%A1%B5%E8%87%AA%E9%80%82%E5%BA%94%E5%A4%A7%E5%B0%8F%2F</url>
    <content type="text"><![CDATA[问题有时候在WKWebView加载页面后会发现页面的字会很小,图片可以左右滑动, 这是因为原网页没有做手机屏幕尺寸的适配 代码如下1234567891011121314151617- (WKWebViewConfiguration *)wkConfig &#123; if (!_wkConfig) &#123; NSString *jScript = @&quot;var meta = document.createElement(&apos;meta&apos;); meta.setAttribute(&apos;name&apos;, &apos;viewport&apos;); meta.setAttribute(&apos;content&apos;, &apos;width=device-width&apos;); document.getElementsByTagName(&apos;head&apos;)[0].appendChild(meta);&quot;; WKUserScript *wkUScript = [[WKUserScript alloc] initWithSource:jScript injectionTime:WKUserScriptInjectionTimeAtDocumentEnd forMainFrameOnly:YES]; WKUserContentController *wkUController = [[WKUserContentController alloc] init]; [wkUController addUserScript:wkUScript]; _wkConfig = [[WKWebViewConfiguration alloc] init]; _wkConfig.allowsInlineMediaPlayback = YES; _wkConfig.userContentController = wkUController; if (@available(iOS 9.0, *)) &#123; _wkConfig.allowsPictureInPictureMediaPlayback = YES; &#125; else &#123; // Fallback on earlier versions &#125; &#125; return _wkConfig;&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vux安装]]></title>
    <url>%2F2018%2F07%2F11%2FVux%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Vux快速安装 123456npm install vue-cli -g # 如果还没安装vue init airyland/vux2 projectPathcd projectPathnpm install --registry=https://registry.npm.taobao.org # 或者 cnpm install 或者 yarnnpm run dev # 或者 yarn dev]]></content>
      <categories>
        <category>Vue</category>
        <category>Vux</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue添加fastclick支持]]></title>
    <url>%2F2018%2F07%2F11%2FVue%E6%B7%BB%E5%8A%A0fastclick%E6%94%AF%E6%8C%81%2F</url>
    <content type="text"><![CDATA[目的：处理移动端Click时间300毫秒延迟 安装执行安装命令npm install fastclick -S 使用在main.js中引入，并绑定到body 12import FastClick from &apos;fastclick&apos;FastClick.attach(document.body);]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS--WKWebView禁用缩放和复制]]></title>
    <url>%2F2018%2F07%2F02%2FiOS-WKWebView%E7%A6%81%E7%94%A8%E7%BC%A9%E6%94%BE%E5%92%8C%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[场景关于App内部WKWebView禁止缩放和长按弹框（出现拷贝、剪贴文本等） 缩放123456789101112WKWebView *webView = [[WKWebView alloc] init];webView.scrollView.delegate = self;......#pragma mark - UIScrollViewDelegate- (UIView *)viewForZoomingInScrollView:(UIScrollView *)scrollView&#123; return nil; // 返回 nil, 不让页面缩放&#125;//记得置空scrollview的代理 不然会出现崩溃- (void)dealloc&#123; _webView.scrollView.delegate = nil;&#125; 禁用复制等网页载入完成执行js 1234-(void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation&#123; [self.webView evaluateJavaScript:@&quot;document.documentElement.style.webkitTouchCallout=&apos;none&apos;;&quot; completionHandler:nil]; [self.webView evaluateJavaScript:@&quot;document.documentElement.style.webkitUserSelect=&apos;none&apos;;&quot;completionHandler:nil];&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii定时任务（Console）的创建]]></title>
    <url>%2F2018%2F05%2F09%2FYii%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%88Console%EF%BC%89%E7%9A%84%E5%88%9B%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[前言在PHP会存在一些情况，比如:用户下单创建的订单有个过期时间，过期了就要让订单失效。这时候就需要定时去查看订单时间是否过期。在Yii中可以创建Console定时任务，来执行一些定时操作。下面记录下关于Console定时任务的创建 创建定时控制器1、在项目根目录里console\controllers，创建一个控制器OrderController。 其中:Controller要继承yii\console\Controller 在OrderController控制器中添加想要实现的定时任务，如：输出 hello world 123public function actionIndex()&#123; echo &quot;hello world&quot;; &#125; 用命令行测试是否可执行成功这里我使用MAC终端链接阿里云服务器，执行以下命令：/var/www/html/blog/yii order/index,效果如下： 其中: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/var/www/html/blog是服务器放代码的根目录 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;order/index是控制器/方法 设置定时任务1、在Linux下，运行crontab -e 2、添加定时程序,比如： */1 * * * * /usr/local/php/bin/php /var/www/html/blog/yii order/index 表示每分钟执行一次order/index方法 3、:wq!保存 定时任务的查看1、查看已经执行的任务，终端执行tail -f /var/log/cron进行查看 从中可以看出定时任务order/index方法，没分钟执行了一次 2、查看所有运行中的进程，终端执行ps aux | less 定时程序的设置1234567891011121314151617基本格式 :* * * * * command分 时 日 月 周 命令第1列表示分钟1～59 每分钟用*或者 */1表示第2列表示小时1～23（0表示0点）第3列表示日期1～31第4列表示月份1～12第5列标识号星期0～6（0表示星期天）第6列要运行的命令 crontab文件的一些例子： 12330 21 * * * /usr/local/php/bin/php /your_project_path/yii order/index#每晚的21:30执行上面例子的定时程序 123456789101112131415161730 21 * * * /usr/local/etc/rc.d/lighttpd restart#上面的例子表示每晚的21:30重启apache。 45 4 1,10,22 * * /usr/local/etc/rc.d/lighttpd restart#上面的例子表示每月1、10、22日的4 : 45重启apache。 10 1 * * 6,0 /usr/local/etc/rc.d/lighttpd restart#上面的例子表示每周六、周日的1 : 10重启apache。 0,30 18-23 * * * /usr/local/etc/rc.d/lighttpd restart#上面的例子表示在每天18 : 00至23 : 00之间每隔30分钟重启apache。 0 23 * * 6 /usr/local/etc/rc.d/lighttpd restart#上面的例子表示每星期六的11 : 00 pm重启apache。 0 */1 * * * /usr/local/etc/rc.d/lighttpd restart#每一小时重启apache]]></content>
      <categories>
        <category>Yii</category>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Yii</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS提示用self替换_的警告]]></title>
    <url>%2F2018%2F05%2F08%2FiOS%E6%8F%90%E7%A4%BA%E7%94%A8self%E6%9B%BF%E6%8D%A2-%E7%9A%84%E8%AD%A6%E5%91%8A%2F</url>
    <content type="text"><![CDATA[警告项目中出现一堆相同的警告：Block implicitly retains ‘self’; explicitly mention ‘self’ to indicate this is intended behavior,其中的意思是block中使用了self的实例变量 _xxx ，因此block会隐式的retain住self。Xcode认为这可能会给开发者造成困惑，或者因此而因袭循环引用，所以警告我们要显示的在block中使用self，以达到block显示retain住self的目的。 解决方法(二种)方法一:按照Xcode提示，改成self-&gt;_xxx方法二:Building Settings-&gt;CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF 设置为NO]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS之NSArray倒序输出]]></title>
    <url>%2F2018%2F04%2F02%2FiOS%E4%B9%8BNSArray%E5%80%92%E5%BA%8F%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[NSArray数组倒序输出1234//1.原始数组NSMutableArray *array = [NSMutableArray arrayWithObjects:@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,nil];//2.倒序的数组NSArray* reversedArray = [[array reverseObjectEnumerator] allObjects];]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS中ExclusiveTouch的设置与作用]]></title>
    <url>%2F2018%2F03%2F22%2FiOS%E4%B8%ADExclusiveTouch%E7%9A%84%E8%AE%BE%E7%BD%AE%E4%B8%8E%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[ExclusiveTouch作用避免在同一个界面上同事点击多个UIButton导致同时响应多个方法 使用全局设置在AppDelegate启动应用时添加(仅支持iOS8+) 1[[UIView appearance] setExclusiveTouch:YES]; 单独设置12UIButton *btn = [UIButton buttonWithType:UIButtonTypeCustom];btn.exclusiveTouch = YES;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS设备的CPU架构]]></title>
    <url>%2F2018%2F03%2F08%2FiOS%E8%AE%BE%E5%A4%87%E7%9A%84CPU%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[模拟器4s-5: i3865s-6s Plus: x86_64 真机(iOS设备)armv6: iPhone、iPhone 2、iPhone 3G、iPod Touch(第一代)、iPod Touch(第二代)armv7: iPhone 3Gs、iPhone 4、iPhone 4s、iPad、iPad 2armv7s: iPhone 5、iPhone 5c (静态库只要支持了armv7,就可以在armv7s的架构上运行)arm64(注:无armv64): iPhone 5s、iPhone 6、iPhone 6 Plus、iPhone 6s、iPhone 6s Plus、iPad Air、iPad Air2、iPad mini2、iPad mini3]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS中CIFilter滤镜的使用]]></title>
    <url>%2F2018%2F03%2F08%2FiOS%E4%B8%ADCIFilter%E6%BB%A4%E9%95%9C%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[简述在这里记录下关于给图片添加滤镜的使用方法 查看滤镜种类123//获取滤镜种类 NSArray *filterNames = [CIFilter filterNamesInCategory:kCICategoryBuiltIn]; NSLog(@&quot;总共有%ld种滤镜效果:%@&quot;,filterNames.count,filterNames); 使用该方法可以获取苹果给的所有滤镜种类有180种 获取带滤镜效果的图片从上方获取想要的滤镜效果 也可以去官方文档查看 各种滤镜的总类效果http://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/filter/ci/ 获取带滤镜效果的图片方法如下: 以CIPhotoEffectTransfer为例 1234567891011121314151617181920212223242526/** 获取带滤镜的图片 @param filterName 滤镜效果名称 @param originImage 原始图 @return 带滤镜的图 */-(UIImage *)getFilterImageToUserFilterName:(NSString *)filterName andOriginImageName:(UIImage *)originImage&#123; CIImage *ciImage =[[CIImage alloc]initWithImage:originImage]; //CIFilter 滤镜 CIFilter *filter = [CIFilter filterWithName:filterName keysAndValues:kCIInputImageKey,ciImage,nil]; //使用默认参数 [filter setDefaults]; //生成上下文 CIContext *context =[CIContext contextWithOptions:nil]; //滤镜生成器输出图片 CIImage *outputImage =[filter outputImage]; //转换为UIImage CGImageRef cgImage =[context createCGImage:outputImage fromRect:[outputImage extent]]; UIImage *image =[UIImage imageWithCGImage:cgImage]; //释放 CGImageRelease(cgImage); return image;&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nohup进程后台运行、查看、终止]]></title>
    <url>%2F2018%2F03%2F05%2Fnohup%E8%BF%9B%E7%A8%8B%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E3%80%81%E6%9F%A5%E7%9C%8B%E3%80%81%E7%BB%88%E6%AD%A2%2F</url>
    <content type="text"><![CDATA[简述关于nohup和&amp;，进程后台运行、查看、终止 nohup和&amp;nohup 命令可以使命令永久的执行下去，和终端没有关系，退出终端也不会影响程序的运行；&amp; 是后台运行的意思，但当用户退出的时候，命令自动也跟着退出。那么，把两个结合起来nohup 命令 &amp;这样就能使命令永久的在后台执行在终端执行nohup 命令 &gt; output.log 2&gt;&amp;1 &amp;nohup+最后面的&amp;是让命令在后台执行 &gt;output.log是将信息输出到output.log日志中 2&gt;&amp;1是将标准错误信息转变成标准输出，这样就可以将错误信息输出到output.log 日志里面来。 查看日志tail -f output.log（动态显示） cat output.log（一次性显示整个文件） 查看当前Python进程ps -ef |grep python 杀死进程sudo kill 进程号 kill 9 进程号 #绝杀]]></content>
      <categories>
        <category>centos</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7 更新Firefox版本]]></title>
    <url>%2F2018%2F03%2F05%2Fcentos7-%E6%9B%B4%E6%96%B0Firefox%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[简述centos系统中，修改Firefox版本，改为Firefox 45.0版本 步骤1、因我的是centos 64位系统，选则下载安装包Firefox-latest-x86_64.tar.bz2 2、进入存放安装包的目录cd /var/temp 3、下载压缩包wget https://download-ssl.firefox.com.cn/releases/firefox/45.0/zh-CN/Firefox-latest-x86_64.tar.bz2 4、解压压缩包tar -xjvf Firefox-latest-x86_64.tar.bz2 5、删除旧版的firefox，通常在/usr/lib64目录下rm -rf /usr/lib64/firefox 6、将当前目录下的新版 firefox 子目录复制到/usr/lib64目录下mv firefox /usr/lib64 7、进入 /usr/bin 目录，删除其下的 firefox 脚本cd /usr/bin rm firefox 8、回到主目录或根目录，创建一个软链接，指向/usr/lib64/firefox/firefoxcd ~ ln -s /usr/lib64/firefox/firefox /usr/bin/firefox 9、查看下最新版本firefox -v]]></content>
      <categories>
        <category>centos</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tar: bzip2：无法 exec: 没有那个文件或目录]]></title>
    <url>%2F2018%2F03%2F05%2Ftar-bzip2%EF%BC%9A%E6%97%A0%E6%B3%95-exec-%E6%B2%A1%E6%9C%89%E9%82%A3%E4%B8%AA%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[问题centos系统中 tar指令打开压缩包报错tar: bzip2：无法 exec: 没有那个文件或目录、 解决系统中缺少bzip2包，执行以下指令yum install -y bzip2]]></content>
      <categories>
        <category>centos</category>
      </categories>
      <tags>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next主题去掉码云的Coding Pages等待跳转页面]]></title>
    <url>%2F2018%2F02%2F28%2FNext%E4%B8%BB%E9%A2%98%E5%8E%BB%E6%8E%89%E7%A0%81%E4%BA%91%E7%9A%84Coding-Pages%E7%AD%89%E5%BE%85%E8%B7%B3%E8%BD%AC%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[###简介Hexo Next静态博客挂在Coding Pages平台上，出现等待跳转页。看得有些烦，纪录下如何去除该界面的方法。(Next版本5.1.4) #####1、升级成银牌会员（必须）完善码云中的个人信息就好了，这是必要步骤 #####2、修改footer.swig文件找到next主题文件下的/themes/next/layout/_partials/footer.swig,找到该行,在第35行这里 1&lt;div class=&quot;theme-info&quot;&gt; 这里放着静态页面底部的一些主题信息，修改代码并添加一句 1&lt;p&gt;Hosted by &lt;a href=&quot;https://pages.coding.me&quot; style=&quot;font-weight: bold&quot;&gt;Coding Pages&lt;/a&gt;&lt;/p&gt; 最后完整的代码是: 12345678910111213&#123;% if theme.footer.powered and theme.footer.theme.enable %&#125; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125;&lt;div class=&quot;theme-info&quot;&gt; &lt;span&gt;Hosted by &lt;a href=&quot;https://pages.coding.me&quot; style=&quot;font-weight: bold&quot;&gt;Coding Pages&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;&#123;% if theme.footer.custom_text %&#125; &lt;div class=&quot;footer-custom&quot;&gt;&#123;# #&#125;&#123;&#123; theme.footer.custom_text &#125;&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125; 前往coding平台对应项目的pages服务页面，在最底部勾选已放置Hosted by Coding Pages选项，等待审核]]></content>
      <categories>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[检测用户截屏，并获取截取的图片]]></title>
    <url>%2F2018%2F02%2F26%2F%E6%A3%80%E6%B5%8B%E7%94%A8%E6%88%B7%E6%88%AA%E5%B1%8F%EF%BC%8C%E5%B9%B6%E8%8E%B7%E5%8F%96%E6%88%AA%E5%8F%96%E7%9A%84%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[记录下关于如何检测用户截屏行为（Home + Power），并获取截屏的图片。。。 注册通知iOS7后提供的一个推送方法UIApplicationUserDidTakeScreenshotNotification，在用户截屏完成后会得到一个通知12// This notification is posted after the user takes a screenshot (for example by pressing both the home and lock screen buttons)UIKIT_EXTERN NSNotificationName const UIApplicationUserDidTakeScreenshotNotification NS_AVAILABLE_IOS(7_0); 123[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(userDidTakeScreenshot:) name:UIApplicationUserDidTakeScreenshotNotification object:nil]; 获取图片123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//截屏响应-(void)userDidTakeScreenshot:(NSNotification *)notificationr&#123; NSLog(@&quot;检测到截屏&quot;); //获取图片，做你想做的事。。。。。。。 UIImage *img=[UIImage imageWithData:[self dataWithScreenshotInPNGFormat]];&#125;//截取当前屏幕-(NSData *)dataWithScreenshotInPNGFormat&#123; CGSize imageSize = CGSizeZero; UIInterfaceOrientation orientation = [UIApplication sharedApplication].statusBarOrientation; if (UIInterfaceOrientationIsPortrait(orientation)) imageSize = [UIScreen mainScreen].bounds.size; else imageSize = CGSizeMake([UIScreen mainScreen].bounds.size.height, [UIScreen mainScreen].bounds.size.width); UIGraphicsBeginImageContextWithOptions(imageSize, NO, [UIScreen mainScreen].scale); CGContextRef context = UIGraphicsGetCurrentContext(); for (UIWindow *window in [[UIApplication sharedApplication] windows]) &#123; CGContextSaveGState(context); CGContextTranslateCTM(context, window.center.x, window.center.y); CGContextConcatCTM(context, window.transform); CGContextTranslateCTM(context, -window.bounds.size.width * window.layer.anchorPoint.x, -window.bounds.size.height * window.layer.anchorPoint.y); if (orientation == UIInterfaceOrientationLandscapeLeft) &#123; CGContextRotateCTM(context, M_PI_2); CGContextTranslateCTM(context, 0, -imageSize.width); &#125; else if (orientation == UIInterfaceOrientationLandscapeRight) &#123; CGContextRotateCTM(context, -M_PI_2); CGContextTranslateCTM(context, -imageSize.height, 0); &#125; else if (orientation == UIInterfaceOrientationPortraitUpsideDown) &#123; CGContextRotateCTM(context, M_PI); CGContextTranslateCTM(context, -imageSize.width, -imageSize.height); &#125; if ([window respondsToSelector:@selector(drawViewHierarchyInRect:afterScreenUpdates:)]) &#123; [window drawViewHierarchyInRect:window.bounds afterScreenUpdates:YES]; &#125; else &#123; [window.layer renderInContext:context]; &#125; CGContextRestoreGState(context); &#125; UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return UIImagePNGRepresentation(image);&#125;//返回截取到的图片-(UIImage *)imageWithScreenshot&#123; NSData *imageData = [self dataWithScreenshotInPNGFormat]; return [UIImage imageWithData:imageData];&#125; 注销通知1234-(void)dealloc&#123; [[NSNotificationCenter defaultCenter]removeObserver:self];&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
</search>
