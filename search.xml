<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[WebViewJavaScriptBridge 基本使用]]></title>
    <url>%2F2019%2F01%2F22%2FWebViewJavaScriptBridge-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[WebViewJavaScriptBridge 基本原理WebViewJavascriptBridge开源库使用，本质上，它也是通过webview的代理拦截scheme，然后注入相应的JS。其中基本原理: 1234567891011121314151617181920- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType &#123; if (webView != _webView) &#123; return YES; &#125; NSURL *url = [request URL]; __strong WVJB_WEBVIEW_DELEGATE_TYPE* strongDelegate = _webViewDelegate; if ([_base isCorrectProcotocolScheme:url]) &#123; if ([_base isBridgeLoadedURL:url]) &#123; [_base injectJavascriptFile]; &#125; else if ([_base isQueueMessageURL:url]) &#123; NSString *messageQueueString = [self _evaluateJavascript:[_base webViewJavascriptFetchQueyCommand]]; [_base flushMessageQueue:messageQueueString]; &#125; else &#123; [_base logUnkownMessage:url]; &#125; return NO; &#125; else if (strongDelegate &amp;&amp; [strongDelegate respondsToSelector:@selector(webView:shouldStartLoadWithRequest:navigationType:)]) &#123; return [strongDelegate webView:webView shouldStartLoadWithRequest:request navigationType:navigationType]; &#125; else &#123; return YES; &#125;&#125; 在拦截后，通过先通过-isBridgeLoadedURL:方法判断URL是否是需要bridge的URL，若是，则通过injectJavascriptFile方法注入JS；否则判断URL是否是队列消息，若是，则执行查询命令JS并刷新消息队列；最后，URL被识别为未知的消息。 WebViewJavaScriptBridge准备工作项目中导入框架 WebViewJavaScriptBridge1pod ‘WebViewJavascriptBridge’ 导入头文件1#import &lt;WebViewJavascriptBridge.h&gt; 建立 WebViewJavaScriptBridge 和 WebView 之间的关系。12345678//给哪个webview建立JS与OjbC的沟通桥梁_jsBridge = [WebViewJavascriptBridge bridgeForWebView:_webView];// 设置代理，如果不需要实现，可以不设置[_jsBridge setWebViewDelegate:self];// 开启日志，方便调试[WebViewJavascriptBridge enableLogging]; 注册block1234567891011121314151617181920212223242526 /** js调用OC的方法 js会调动refresh方法，这是OC注册给JS调用的 @param data js传递过来的参数 不一定要传 @param responseCallback OC端执行完毕后 OC端通过responseCallback回调JS端 JS端可以得到所需要的数据 @return return value description */[_jsBridge registerHandler:@&quot;refresh&quot; handler:^(id data, WVJBResponseCallback responseCallback) &#123; NSLog(@&quot;js call getBlogNameFromObjC, data from js is %@&quot;, data); self.navigationController.navigationBar.barTintColor = [UIColor redColor]; if (responseCallback) &#123; // 反馈给JS responseCallback(data); &#125;&#125;]; /** OC调用js的方法 js会调用bgColor方法 直接调用js端注册的bgColor方法 @param data OC传递给js的参数 @param responseData JS端通过responseCallback回调OC端 OC端可以得到js传递回来的参数 @return return value description */[_jsBridge callHandler:@&quot;bgColor&quot; data:@&quot;tom&quot; responseCallback:^(id responseData) &#123; NSLog(responseData);&#125;]; 移除注册的oc block123456-(void)viewDidDisappear:(BOOL)animated&#123; [super viewDidDisappear:animated]; [_jsBridge removeHandler:@&quot;refresh&quot;]; [_jsBridge removeHandler:@&quot;bgColor&quot;];&#125; js端所需要的步骤将下面的代码放入JS中: 123456789101112131415/*这段代码是固定的，必须要放到js中*/function setupWebViewJavascriptBridge(callback) &#123; if (window.WebViewJavascriptBridge) &#123; return callback(WebViewJavascriptBridge); &#125; if (window.WVJBCallbacks) &#123; return window.WVJBCallbacks.push(callback); &#125; window.WVJBCallbacks = [callback]; var WVJBIframe = document.createElement(&apos;iframe&apos;); WVJBIframe.style.display = &apos;none&apos;; WVJBIframe.src = &apos;wvjbscheme://__BRIDGE_LOADED__&apos;; document.documentElement.appendChild(WVJBIframe); setTimeout(function() &#123; document.documentElement.removeChild(WVJBIframe) &#125;, 0)&#125;setupWebViewJavascriptBridge(function(bridge) &#123; /* Initialize your app here */ //所有与iOS交互的JS代码放这里！&#125;) demo中 的html文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;!-- Required meta tags --&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt; &lt;!-- Bootstrap CSS --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.bootcss.com/bootstrap/4.0.0/css/bootstrap.min.css&quot; integrity=&quot;sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm&quot; crossorigin=&quot;anonymous&quot;&gt; &lt;title&gt;无网络&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin: 0; padding: 0; &#125; html,body&#123; width: 100%; height: 100%; &#125; .box&#123; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; flex-direction: column; &#125; .pic&#123; margin: 0 auto; padding: 0; width: 100px; height: 100px; &#125; .text&#123; padding: 10px; font-size: 20px; color: #e6e6e6; &#125; .btn-get&#123; cursor: pointer; color: #e6e6e6; border: 1px solid #e6e6e6; border-radius: 8px; padding: 10px 20px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;img class=&quot;pic&quot; src=&quot;./无网络.png&quot; /&gt; &lt;div class=&quot;text&quot;&gt;当前没有网络哦~&lt;/div&gt; &lt;div class=&quot;btn-get&quot; id=&quot;btn-get&quot; &gt;点击重新加载&lt;/div&gt; &lt;/div&gt; &lt;!-- Optional JavaScript --&gt; &lt;!-- jQuery first, then Popper.js, then Bootstrap JS --&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.2.1/jquery.slim.min.js&quot; integrity=&quot;sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/popper.js/1.12.9/umd/popper.min.js&quot; integrity=&quot;sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/bootstrap/4.0.0/js/bootstrap.min.js&quot; integrity=&quot;sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; /*这段代码是固定的，必须要放到js中*/ function setupWebViewJavascriptBridge(callback) &#123; if (window.WebViewJavascriptBridge) &#123; return callback(WebViewJavascriptBridge); &#125; if (window.WVJBCallbacks) &#123; return window.WVJBCallbacks.push(callback); &#125; window.WVJBCallbacks = [callback]; var WVJBIframe = document.createElement(&apos;iframe&apos;); WVJBIframe.style.display = &apos;none&apos;; WVJBIframe.src = &apos;wvjbscheme://__BRIDGE_LOADED__&apos;; document.documentElement.appendChild(WVJBIframe); setTimeout(function() &#123; document.documentElement.removeChild(WVJBIframe) &#125;, 0) &#125; setupWebViewJavascriptBridge(function(bridge) &#123; /* Initialize your app here */ document.getElementById(&apos;btn-get&apos;).onclick = function (e) &#123; alert(&quot;JS 调用了 OC&quot;); bridge.callHandler(&apos;refresh&apos;,&#123;&apos;url&apos;: &apos;http://www.baidu.com&apos;&#125;,function(response) &#123; alert(&quot;JS 调用了 OC 注册的 colorClick 方法&quot;+response); &#125;) &#125;; bridge.registerHandler(&apos;bgColor&apos;,function(data,responseCallback)&#123; alert(&apos;oc调用js bgColor&apos;+ data); document.body.style.backgroundColor = &quot;orange&quot;; responseCallback(&apos;tom&apos;); &#125;); &#125;) &lt;/script&gt;&lt;/html&gt; JS调用OC场景在html中有个按钮，点击后更改iOS中NavigationBar的颜色 1、在OC中，通过 WebViewJavascriptBridge 注册一个修改 navigationBar 颜色的 Block 别名为 refresh。 12345678910111213141516/** js调用OC的方法 js会调动refresh方法，这是OC注册给JS调用的 @param data js传递过来的参数 不一定要传 @param responseCallback OC端执行完毕后 OC端通过responseCallback回调JS端 JS端可以得到所需要的数据 @return return value description */[_jsBridge registerHandler:@&quot;refresh&quot; handler:^(id data, WVJBResponseCallback responseCallback) &#123; NSLog(@&quot;js call getBlogNameFromObjC, data from js is %@&quot;, data); self.navigationController.navigationBar.barTintColor = [UIColor redColor]; [ws getAdData]; if (responseCallback) &#123; // 反馈给JS responseCallback(data); &#125;&#125;]; 2、在js中 往桥梁里 注册一个 别名为refresh的方法 123456789setupWebViewJavascriptBridge(function(bridge) &#123; /* Initialize your app here */ document.getElementById(&apos;btn-get&apos;).onclick = function (e) &#123; alert(&quot;JS 调用了 OC&quot;); bridge.callHandler(&apos;refresh&apos;,&#123;&apos;url&apos;: &apos;http://www.baidu.com&apos;&#125;,function(response) &#123; alert(&quot;JS 调用了 OC 注册的 colorClick 方法&quot;+response); &#125;) &#125;;&#125;) 该方法的其他使用方法 1234567891011// JS 单纯的调用 OC 的 blockbridge.callHandler(&apos;refresh&apos;);// JS 调用 OC 的 block，并传递 JS 参数bridge.callHandler(&apos;refresh&apos;,&quot;JS 参数&quot;);// JS 调用 OC 的 block，传递 JS 参数，并接受 OC 的返回值。bridge.callHandler(&apos;refresh&apos;,&#123;data : &quot;这是 JS 传递到 OC 的扫描数据&quot;&#125;,function(dataFromOC)&#123; alert(&quot;JS 调用了 OC 的扫描方法!&quot;); document.getElementById(&quot;returnValue&quot;).value = dataFromOC;&#125;); OC调用JS场景通过OC中的一个按钮点击，更改html里body的背景颜色 1、在js中，往桥梁中 注册一个修改body背景颜色的方法 别名为bgColor 12345678setupWebViewJavascriptBridge(function(bridge) &#123; /* Initialize your app here */ bridge.registerHandler(&apos;bgColor&apos;,function(data,responseCallback)&#123; alert(&apos;oc调用js bgColor&apos;+ data); document.body.style.backgroundColor = &quot;orange&quot;; responseCallback(&apos;tom&apos;); &#125;);&#125;) 2、在OC端通过桥梁调用这个bgColor 123456789/** OC调用js的方法 js会调用bgColor方法 直接调用js端注册的bgColor方法 @param data OC传递给js的参数 @param responseData JS端通过responseCallback回调OC端 OC端可以得到js传递回来的参数 @return return value description */[_jsBridge callHandler:@&quot;bgColor&quot; data:@&quot;tom&quot; responseCallback:^(id responseData) &#123; NSLog(responseData);&#125;]; 该方法的其他使用方法 12345678// 单纯的调用 JSFunction，不往 JS 传递参数，也不需要 JSFunction 的返回值。[_jsBridge callHandler:@&quot;bgColor&quot;];// 调用 JSFunction，并向 JS 传递参数，但不需要 JSFunciton 的返回值。[_jsBridge callHandler:@&quot;bgColor&quot; data:@&quot;把 HTML 的背景颜色改成橙色!!!!&quot;];// 调用 JSFunction ，并向 JS 传递参数，也需要 JSFunction 的返回值。[_jsBridge callHandler:@&quot;bgColor&quot; data:@&quot;传递给 JS 的参数&quot; responseCallback:^(id responseData) &#123; NSLog(@&quot;JS 的返回值: %@&quot;,responseData);&#125;];]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS提示用self替换_的警告]]></title>
    <url>%2F2019%2F01%2F16%2FiOS%E6%8F%90%E7%A4%BA%E7%94%A8self%E6%9B%BF%E6%8D%A2-%E7%9A%84%E8%AD%A6%E5%91%8A-1%2F</url>
    <content type="text"><![CDATA[问题: iOS出现Block implicitly retains ‘self’; explicitly mention ‘self’ to indicate this…警告 解决: Building Settings -&gt;CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF=NO]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客中不蒜子统计无法显示问题]]></title>
    <url>%2F2019%2F01%2F16%2Fhexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E4%B8%8D%E8%92%9C%E5%AD%90%E7%BB%9F%E8%AE%A1%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题: 最近博客中的访问统计无法显示原因:不蒜子统计的域名过期了，而js的引用就会有问题解决方法:1、找到NexT下引用不蒜子统计的方法。文件路径为/theme/next/layout/_third-party/analytics/busuanzi-counter.swig文件。2、将里面的dn-lbstatics.qbox.me替换为busuanzi.ibruce.info]]></content>
      <categories>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS调用系统震动、系统提示音]]></title>
    <url>%2F2019%2F01%2F16%2FiOS%E8%B0%83%E7%94%A8%E7%B3%BB%E7%BB%9F%E9%9C%87%E5%8A%A8%E3%80%81%E7%B3%BB%E7%BB%9F%E6%8F%90%E7%A4%BA%E9%9F%B3%2F</url>
    <content type="text"><![CDATA[系统震动12345// 导入框架#import &lt;AudioToolbox/AudioToolbox.h&gt;// 调用方法AudioServicesPlaySystemSound(kSystemSoundID_Vibrate); 系统提示音12345// 导入框架#import &lt;AudioToolbox/AudioToolbox.h&gt;// 调用方法AudioServicesPlaySystemSound(1007); //这个声音是是类似于QQ声音的 自定义提示音123456789SystemSoundID sourceID; //调用NSBundle类的方法mainBundle返回一个NSBundle对象，该对象对应于当前程序可执行二进制文件所属的目录 NSString *soundFile = [[NSBundle mainBundle] pathForResource:@&quot;soundeffect&quot; ofType:@&quot;wav&quot;]; //一个指向文件位置的CFURLRef对象和一个指向要设置的SystemSoundID变量的指针 AudioServicesCreateSystemSoundID((CFURLRef) [NSURL fileURLWithPath:soundFile], &amp;soundID); AudioServicesPlaySystemSound(soundID); 一些系统的基本提示音的SoundName(名称)和SoundType(后缀)分别对应下面的数据: 例：ReceivedMessage.caf声音中ReceivedMessage 为soundName, caf为soundType 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859信息 ReceivedMessage.caf--收到信息，仅在短信界面打开时播放。 sms-received1.caf-------三全音 sms-received2.caf-------管钟琴 sms-received3.caf-------玻璃 sms-received4.caf-------圆号 sms-received5.caf-------铃声 sms-received6.caf-------电子乐 SentMessage.caf--------发送信息 邮件 mail-sent.caf----发送邮件 new-mail.caf-----收到新邮件 电话 dtmf-0.caf----------拨号面板0按键 dtmf-1.caf----------拨号面板1按键 dtmf-2.caf----------拨号面板2按键 dtmf-3.caf----------拨号面板3按键 dtmf-4.caf----------拨号面板4按键 dtmf-5.caf----------拨号面板5按键 dtmf-6.caf----------拨号面板6按键 dtmf-7.caf----------拨号面板7按键 dtmf-8.caf----------拨号面板8按键dtmf-9.caf----------拨号面板9按键 dtmf-pound.caf---拨号面板＃按键 dtmf-star.caf------拨号面板*按键 Voicemail.caf-----新语音邮件 输入设备声音提示 Tock.caf-----------------------点击键盘 begin_record.caf-----------开始录音 begin_video_record.caf--开始录像 photoShutter.caf------------快门声 end_record.caf--------------结束录音 end_video_record.caf-----结束录像 其他 beep-beep.caf--充电、注销及连接电脑 lock.caf------------锁定手机 shake.caf---------“这个还没搞清楚” unlock.caf--------滑动解锁 low_power.caf--低电量提示语音控制 jbl_ambiguous.caf--找到多个匹配 jbl_begin.caf------等待用户的输入 jbl_cancel.caf-----取消 jbl_confirm.caf----执行 jbl_no_match.caf---没有找到匹配 日历 alarm.caf--日历提醒 iPod Touch 1G sq_alarm.caf sq_beep-beep.caf sq_lock.caf sq_tock.caf]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS保持屏幕常亮及改变屏幕显示亮度]]></title>
    <url>%2F2019%2F01%2F16%2FiOS%E4%BF%9D%E6%8C%81%E5%B1%8F%E5%B9%95%E5%B8%B8%E4%BA%AE%E5%8F%8A%E6%94%B9%E5%8F%98%E5%B1%8F%E5%B9%95%E6%98%BE%E7%A4%BA%E4%BA%AE%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[12345// 屏幕处于常亮，保持唤醒状态。默认为NO,注意在适当的时候设为默认 [[UIApplication sharedApplication] setIdleTimerDisabled:YES];// 亮度的数值处于0.0 - 1.0 之间[[UIScreen mainScreen] setBrightness: 0.5];]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[class-dump安装与使用]]></title>
    <url>%2F2018%2F10%2F17%2Fclass-dump%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[简介class-dump是用来dump目标文件的类信息的工具。它利用Objective-C语言的runtime的特性，将存储在mach-O文件中的@interface和@protocol信息提取出来，并生成对应的.h文件。官方介绍如下： This is a command-line utility for examining the Objective-C runtime information stored in Mach-O files. It generates declarations for the classes, categories and protocols. This is the same information provided by using ‘otool -ov’, but presented as normal Objective-C declarations, so it is much more compact and readable. 安装class-dump打开链接后http://stevenygard.com/projects/class-dump/，选择class-dump-3.5.dmg,进行下载。下载完成之后，将dmg文件中的class-dump复制到/usr/bin目录，并在终端执行如下执行进行赋权： 1sudo chmod 777 /usr/bin/class-dump 如果是OS X 10.11，因为没有/usr/bin文件夹的写权限，所以将class-dump复制到/usr/local/bin目录下即可。并在终端执行如下执行进行赋权： 1sudo chmod 777 /usr/local/bin/class-dump 然后运行class-dump指令，即可看到如下结果： 123456789101112131415161718192021appledeMac-mini-2:bin liu$ class-dumpclass-dump 3.5 (64 bit)Usage: class-dump [options] &lt;mach-o-file&gt; where options are: -a show instance variable offsets -A show implementation addresses --arch &lt;arch&gt; choose a specific architecture from a universal binary (ppc, ppc64, i386, x86_64, armv6, armv7, armv7s, arm64) -C &lt;regex&gt; only display classes matching regular expression -f &lt;str&gt; find string in method name -H generate header files in current directory, or directory specified with -o -I sort classes, categories, and protocols by inheritance (overrides -s) -o &lt;dir&gt; output directory used for -H -r recursively expand frameworks and fixed VM shared libraries -s sort classes and categories by name -S sort methods by name -t suppress header in output, for testing --list-arches list the arches in the file, then exit --sdk-ios specify iOS SDK version (will look in /Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS&lt;version&gt;.sdk --sdk-mac specify Mac OS X version (will look in /Developer/SDKs/MacOSX&lt;version&gt;.sdk --sdk-root specify the full SDK root path (or use --sdk-ios/--sdk-mac for a shortcut) 使用class-dump使用class-dump导出头文件的命令格式： class-dump -H 需要导出的框架路径 -o 导出的头文件存放路径]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue项目中vue-layer弹框的使用]]></title>
    <url>%2F2018%2F09%2F05%2Fvue%E9%A1%B9%E7%9B%AE%E4%B8%ADvue-layer%E5%BC%B9%E6%A1%86%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[安装1npm install vue-layer 引用在程序入口添加123import Vue from &apos;vue&apos;;import layer from &apos;vue-layer&apos;Vue.prototype.$layer = layer(Vue); 全局参数重置12345import Vue from &apos;vue&apos;;import layer from &apos;vue-layer&apos;Vue.prototype.$layer = layer(Vue, &#123; msgtime: 3,//目前只有一项，即msg方法的默认消失时间，单位：秒&#125;); 参数说明1234567891011121314151617&#123; type: 0, //0（信息框，默认）1（页面层）2（iframe层）3（加载层）4（tips层） title: &apos;信息&apos;, content: &apos;&apos;, area: &apos;auto&apos;, offset: &apos;auto&apos;, icon: -1, btn: &apos;确定&apos;, time: 0, shade: true,//是否显示遮罩 yes: &apos;&apos;, cancel: &apos;&apos;, tips: [0,&#123;&#125;],//支持上右下左四个方向，通过1-4进行方向设定,可以设定tips: [1, &apos;#c00&apos;] tipsMore: false,//是否允许多个tips shadeClose: true,//点击遮罩是否关闭&#125; 调用方法123layer.alert(content, [options, yes]); // options和yes可以省略， 如果您不愿意写options，则可以直接写确定按钮的函数，即yes // content 可以为html 123layer.confirm(content, [options, yes, cancel]); // options，yes和cancel可以省略， 如果您不愿意写options，则可以直接写确定按钮的函数，即yes，或者覆盖默认的cancel方法。PS：yes和cancel方法不能互换 //content 可以为html 1234layer.msg(content, [options, end]); // options和end可以省略， 如果您不愿意写options，则可以直接写时间到期的回调即可，即end方法 // 默认msg的关闭时间为1.5秒 // content 可以为html 123layer.tips(content, follow, options);//content 可以为html//follow对css选择器，用来定位目标 123456789101112131415161718192021222324252627282930313233343536373839404142layer.iframe(&#123; content: &#123; content: componentName, //传递的组件对象 parent: this,//当前的vue对象 data:&#123;&#125;//props &#125;, area:[&apos;800px&apos;,&apos;600px&apos;], title: &apos;title&apos;&#125;);// data参数可认为是componentName的props，同时 该方法会自动添加一个key为layerid的值， 该值为创建层的id， 可以直接用来关闭该层// options参数直接写到json里即可，比如title其实使用iframe层，除了操作方便外，主要的目的是隔离代码， 降低代码复杂度。而在vue中，组件就是功能块的基本单位了，所以vue-layer中并不存在iframe的DOM元素，这里用的都是组件。 这里的content有三个参数：##### content: 此参数为组件对象， 比如 import editFrom from &apos;./edir-form.vue&apos;;此处content就为editFrom即可。##### parent:此参数其实就是当前调用layer的vue对象， 即this即可。在editForm中可以直接使用， this.$parent来获取调用layer的vue对象，然后父子传值神马的，就很easy，当然也可以直接使用vuex，就不用this.$parent了##### data: 此参数可认为是editForm的props，然后你懂得。 注： 该方法会自动添加一个key为layerid的值， 该值为创建层的id， 可以直接使用结果即为：methods:&#123; eidt() &#123; this.$layer.iframe(&#123; content: &#123; content: editForm, //传递的组件对象 parent: this,//当前的vue对象 data:&#123;&#125;//props &#125;, area:[&apos;800px&apos;,&apos;600px&apos;], title:&quot;editForm&quot; &#125;); &#125;&#125; 1layer.open(options); 1layer.close(id); 1layer.closeAll(type); 样式调整1该包的css都为vl-notice开头， 需要重写css样式，覆盖即可]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS打开设置页面及其中某指定的选项界面]]></title>
    <url>%2F2018%2F08%2F10%2FiOS%E6%89%93%E5%BC%80%E8%AE%BE%E7%BD%AE%E9%A1%B5%E9%9D%A2%E5%8F%8A%E5%85%B6%E4%B8%AD%E6%9F%90%E6%8C%87%E5%AE%9A%E7%9A%84%E9%80%89%E9%A1%B9%E7%95%8C%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[打开的代码： 123456789/** 打开设置页面或设置中某个页面 */-(void)goTAppSystem&#123; NSURL *url = [NSURL URLWithString:@&quot;prefs:root=General&quot;]; if ([[UIApplication sharedApplication] canOpenURL:url]) &#123; [[UIApplication sharedApplication] openURL:url]; &#125;&#125; 其他可用的一些参数: 1234567891011121314151617181920212223242526272829303132333435363738394041prefs:root=General&amp;path=About //关于prefs:root=General&amp;path=ACCESSIBILITY //重力感应prefs:root=AIRPLANE_MODE //飞行模式prefs:root=General&amp;path=AUTOLOCK //自动锁定prefs:root=General&amp;path=USAGE/CELLULAR_USAGE //用量prefs:root=Brightness //打开Brightness(亮度)设置界面prefs:root=Bluetooth //打开蓝牙设置prefs:root=General&amp;path=DATE_AND_TIME //日期与时间设置prefs:root=FACETIME //打开FaceTime设置prefs:root=General //打开通用设置prefs:root=General&amp;path=Keyboard //打开键盘设置prefs:root=CASTLE //打开iClound设置prefs:root=CASTLE&amp;path=STORAGE_AND_BACKUP //打开iCloud下的储存空间prefs:root=General&amp;path=INTERNATIONAL //打开通用下的语言和地区设置prefs:root=LOCATION_SERVICES //打开隐私下的定位服务prefs:root=ACCOUNT_SETTINGSprefs:root=MUSIC //打开设置下的音乐prefs:root=MUSIC&amp;path=EQ //打开音乐下的均衡器prefs:root=MUSIC&amp;path=VolumeLimit //打开音乐下的音量prefs:root=General&amp;path=Network //打开通用下的网络prefs:root=NIKE_PLUS_IPOD prefs:root=NOTES //打开设置下的备忘录设置prefs:root=NOTIFICATIONS_ID //打开设置下的通知设置prefs:root=Phone //打开电话设置prefs:root=Photos //打开设置下照片和相机设置prefs:root=General&amp;path=ManagedConfigurationList //打开通用下的描述文件prefs:root=General&amp;path=Reset //打开通用下的还原设置prefs:root=Sounds&amp;path=Ringtoneprefs:root=Safari //打开设置下的safari设置prefs:root=General&amp;path=Assistant //打开siri不成功prefs:root=Sounds //打开设置下的声音设置prefs:root=General&amp;path=SOFTWARE_UPDATE_LINK //打开通用下的软件更新prefs:root=STORE //打开通用下的iTounes Store和App Store设置prefs:root=TWITTER //打开设置下的twitter设置prefs:root=FACEBOOK //打开设置下的Facebook设置prefs:root=General&amp;path=USAGE //打开通用下的用量prefs:root=VIDEO //视频prefs:root=General&amp;path=Network/VPN //打开通用下的vpn设置prefs:root=Wallpaper //打开设置下的墙纸设置prefs:root=WIFI //打开wifi设置prefs:root=INTERNET_TETHERING]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS获取通知开启状态，并跳转到设置页面]]></title>
    <url>%2F2018%2F08%2F10%2FiOS%E8%8E%B7%E5%8F%96%E9%80%9A%E7%9F%A5%E5%BC%80%E5%90%AF%E7%8A%B6%E6%80%81%EF%BC%8C%E5%B9%B6%E8%B7%B3%E8%BD%AC%E5%88%B0%E8%AE%BE%E7%BD%AE%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[获取系统通知状态123456789101112131415161718192021/** 获取系统消息通知是否开启 @return YES为开启 NO为关闭 */- (BOOL)isUserNotificationEnable &#123; // 判断用户是否允许接收通知 BOOL isEnable = NO; if (@available(iOS 8.0, *)) &#123; // iOS版本 &gt;=8.0 处理逻辑 UIUserNotificationSettings *setting = [[UIApplication sharedApplication] currentUserNotificationSettings]; isEnable = (UIUserNotificationTypeNone == setting.types) ? NO : YES; &#125; else &#123; // iOS版本 &lt;8.0 处理逻辑 UIRemoteNotificationType type = [[UIApplication sharedApplication] enabledRemoteNotificationTypes]; isEnable = (UIRemoteNotificationTypeNone == type) ? NO : YES; &#125; return isEnable;&#125; 前往设置页面用户为开启通知，可以提示用户直接去设置页面开启通知，前往设置页面代码如下： 12345678910111213141516171819202122/** 如果用户关闭了接收通知功能，该方法可以跳转到APP设置页面进行修改 iOS版本 &gt;=8.0 处理逻辑 */- (void)goToAppSystemSetting &#123; UIApplication *application = [UIApplication sharedApplication]; NSURL *url = [NSURL URLWithString:UIApplicationOpenSettingsURLString]; if ([application canOpenURL:url]) &#123; if ([application respondsToSelector:@selector(openURL:options:completionHandler:)]) &#123; if (@available(iOS 10.0, *)) &#123; [application openURL:url options:@&#123;&#125; completionHandler:nil]; &#125; else &#123; // Fallback on earlier versions &#125; &#125; else &#123; [application openURL:url]; &#125; &#125; &#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS中UIWebView禁用放大镜、拷贝粘贴弹出框]]></title>
    <url>%2F2018%2F07%2F16%2FiOS%E4%B8%ADUIWebView%E7%A6%81%E7%94%A8%E6%94%BE%E5%A4%A7%E9%95%9C%E3%80%81%E6%8B%B7%E8%B4%9D%E7%B2%98%E8%B4%B4%E5%BC%B9%E5%87%BA%E6%A1%86%2F</url>
    <content type="text"><![CDATA[需求禁用UIWebView网页中放大镜、拷贝粘贴弹出框 方法在UIWebView网页中长按手势默认是0.5秒，添加一个自定义的长按手势 时间小于0.5秒就行，代码如下 1234567891011121314- (void)viewDidLoad &#123; [super viewDidLoad]; UILongPressGestureRecognizer *longPress = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:nil]; longPress.delegate = self; //记得在.h文件里加上&lt;UIGestureRecognizerDelegate&gt;委托 longPress.minimumPressDuration = 0.4; //小于0.5秒 [self.webView addGestureRecognizer:longPress];&#125;#pragma mark - GestureRecognizerDelegate- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer&#123; return NO; &#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WKWebView加载的网页自适应大小]]></title>
    <url>%2F2018%2F07%2F12%2FWKWebView%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%BD%91%E9%A1%B5%E8%87%AA%E9%80%82%E5%BA%94%E5%A4%A7%E5%B0%8F%2F</url>
    <content type="text"><![CDATA[问题有时候在WKWebView加载页面后会发现页面的字会很小,图片可以左右滑动, 这是因为原网页没有做手机屏幕尺寸的适配 代码如下1234567891011121314151617- (WKWebViewConfiguration *)wkConfig &#123; if (!_wkConfig) &#123; NSString *jScript = @&quot;var meta = document.createElement(&apos;meta&apos;); meta.setAttribute(&apos;name&apos;, &apos;viewport&apos;); meta.setAttribute(&apos;content&apos;, &apos;width=device-width&apos;); document.getElementsByTagName(&apos;head&apos;)[0].appendChild(meta);&quot;; WKUserScript *wkUScript = [[WKUserScript alloc] initWithSource:jScript injectionTime:WKUserScriptInjectionTimeAtDocumentEnd forMainFrameOnly:YES]; WKUserContentController *wkUController = [[WKUserContentController alloc] init]; [wkUController addUserScript:wkUScript]; _wkConfig = [[WKWebViewConfiguration alloc] init]; _wkConfig.allowsInlineMediaPlayback = YES; _wkConfig.userContentController = wkUController; if (@available(iOS 9.0, *)) &#123; _wkConfig.allowsPictureInPictureMediaPlayback = YES; &#125; else &#123; // Fallback on earlier versions &#125; &#125; return _wkConfig;&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vux安装]]></title>
    <url>%2F2018%2F07%2F11%2FVux%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Vux快速安装 123456npm install vue-cli -g # 如果还没安装vue init airyland/vux2 projectPathcd projectPathnpm install --registry=https://registry.npm.taobao.org # 或者 cnpm install 或者 yarnnpm run dev # 或者 yarn dev]]></content>
      <categories>
        <category>Vue</category>
        <category>Vux</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue添加fastclick支持]]></title>
    <url>%2F2018%2F07%2F11%2FVue%E6%B7%BB%E5%8A%A0fastclick%E6%94%AF%E6%8C%81%2F</url>
    <content type="text"><![CDATA[目的：处理移动端Click时间300毫秒延迟 安装执行安装命令npm install fastclick -S 使用在main.js中引入，并绑定到body 12import FastClick from &apos;fastclick&apos;FastClick.attach(document.body);]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS--WKWebView禁用缩放和复制]]></title>
    <url>%2F2018%2F07%2F02%2FiOS-WKWebView%E7%A6%81%E7%94%A8%E7%BC%A9%E6%94%BE%E5%92%8C%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[场景关于App内部WKWebView禁止缩放和长按弹框（出现拷贝、剪贴文本等） 缩放123456789101112WKWebView *webView = [[WKWebView alloc] init];webView.scrollView.delegate = self;......#pragma mark - UIScrollViewDelegate- (UIView *)viewForZoomingInScrollView:(UIScrollView *)scrollView&#123; return nil; // 返回 nil, 不让页面缩放&#125;//记得置空scrollview的代理 不然会出现崩溃- (void)dealloc&#123; _webView.scrollView.delegate = nil;&#125; 禁用复制等网页载入完成执行js 1234-(void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation&#123; [self.webView evaluateJavaScript:@&quot;document.documentElement.style.webkitTouchCallout=&apos;none&apos;;&quot; completionHandler:nil]; [self.webView evaluateJavaScript:@&quot;document.documentElement.style.webkitUserSelect=&apos;none&apos;;&quot;completionHandler:nil];&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii定时任务（Console）的创建]]></title>
    <url>%2F2018%2F05%2F09%2FYii%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%88Console%EF%BC%89%E7%9A%84%E5%88%9B%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[前言在PHP会存在一些情况，比如:用户下单创建的订单有个过期时间，过期了就要让订单失效。这时候就需要定时去查看订单时间是否过期。在Yii中可以创建Console定时任务，来执行一些定时操作。下面记录下关于Console定时任务的创建 创建定时控制器1、在项目根目录里console\controllers，创建一个控制器OrderController。 其中:Controller要继承yii\console\Controller 在OrderController控制器中添加想要实现的定时任务，如：输出 hello world 123public function actionIndex()&#123; echo &quot;hello world&quot;; &#125; 用命令行测试是否可执行成功这里我使用MAC终端链接阿里云服务器，执行以下命令：/var/www/html/blog/yii order/index,效果如下： 其中: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/var/www/html/blog是服务器放代码的根目录 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;order/index是控制器/方法 设置定时任务1、在Linux下，运行crontab -e 2、添加定时程序,比如： */1 * * * * /usr/local/php/bin/php /var/www/html/blog/yii order/index 表示每分钟执行一次order/index方法 3、:wq!保存 定时任务的查看1、查看已经执行的任务，终端执行tail -f /var/log/cron进行查看 从中可以看出定时任务order/index方法，没分钟执行了一次 2、查看所有运行中的进程，终端执行ps aux | less 定时程序的设置1234567891011121314151617基本格式 :* * * * * command分 时 日 月 周 命令第1列表示分钟1～59 每分钟用*或者 */1表示第2列表示小时1～23（0表示0点）第3列表示日期1～31第4列表示月份1～12第5列标识号星期0～6（0表示星期天）第6列要运行的命令 crontab文件的一些例子： 12330 21 * * * /usr/local/php/bin/php /your_project_path/yii order/index#每晚的21:30执行上面例子的定时程序 123456789101112131415161730 21 * * * /usr/local/etc/rc.d/lighttpd restart#上面的例子表示每晚的21:30重启apache。 45 4 1,10,22 * * /usr/local/etc/rc.d/lighttpd restart#上面的例子表示每月1、10、22日的4 : 45重启apache。 10 1 * * 6,0 /usr/local/etc/rc.d/lighttpd restart#上面的例子表示每周六、周日的1 : 10重启apache。 0,30 18-23 * * * /usr/local/etc/rc.d/lighttpd restart#上面的例子表示在每天18 : 00至23 : 00之间每隔30分钟重启apache。 0 23 * * 6 /usr/local/etc/rc.d/lighttpd restart#上面的例子表示每星期六的11 : 00 pm重启apache。 0 */1 * * * /usr/local/etc/rc.d/lighttpd restart#每一小时重启apache]]></content>
      <categories>
        <category>Yii</category>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Yii</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS提示用self替换_的警告]]></title>
    <url>%2F2018%2F05%2F08%2FiOS%E6%8F%90%E7%A4%BA%E7%94%A8self%E6%9B%BF%E6%8D%A2-%E7%9A%84%E8%AD%A6%E5%91%8A%2F</url>
    <content type="text"><![CDATA[警告项目中出现一堆相同的警告：Block implicitly retains ‘self’; explicitly mention ‘self’ to indicate this is intended behavior,其中的意思是block中使用了self的实例变量 _xxx ，因此block会隐式的retain住self。Xcode认为这可能会给开发者造成困惑，或者因此而因袭循环引用，所以警告我们要显示的在block中使用self，以达到block显示retain住self的目的。 解决方法(二种)方法一:按照Xcode提示，改成self-&gt;_xxx方法二:Building Settings-&gt;CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF 设置为NO]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS之NSArray倒序输出]]></title>
    <url>%2F2018%2F04%2F02%2FiOS%E4%B9%8BNSArray%E5%80%92%E5%BA%8F%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[NSArray数组倒序输出1234//1.原始数组NSMutableArray *array = [NSMutableArray arrayWithObjects:@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,nil];//2.倒序的数组NSArray* reversedArray = [[array reverseObjectEnumerator] allObjects];]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS中ExclusiveTouch的设置与作用]]></title>
    <url>%2F2018%2F03%2F22%2FiOS%E4%B8%ADExclusiveTouch%E7%9A%84%E8%AE%BE%E7%BD%AE%E4%B8%8E%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[ExclusiveTouch作用避免在同一个界面上同事点击多个UIButton导致同时响应多个方法 使用全局设置在AppDelegate启动应用时添加(仅支持iOS8+) 1[[UIView appearance] setExclusiveTouch:YES]; 单独设置12UIButton *btn = [UIButton buttonWithType:UIButtonTypeCustom];btn.exclusiveTouch = YES;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS设备的CPU架构]]></title>
    <url>%2F2018%2F03%2F08%2FiOS%E8%AE%BE%E5%A4%87%E7%9A%84CPU%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[模拟器4s-5: i3865s-6s Plus: x86_64 真机(iOS设备)armv6: iPhone、iPhone 2、iPhone 3G、iPod Touch(第一代)、iPod Touch(第二代)armv7: iPhone 3Gs、iPhone 4、iPhone 4s、iPad、iPad 2armv7s: iPhone 5、iPhone 5c (静态库只要支持了armv7,就可以在armv7s的架构上运行)arm64(注:无armv64): iPhone 5s、iPhone 6、iPhone 6 Plus、iPhone 6s、iPhone 6s Plus、iPad Air、iPad Air2、iPad mini2、iPad mini3]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS中CIFilter滤镜的使用]]></title>
    <url>%2F2018%2F03%2F08%2FiOS%E4%B8%ADCIFilter%E6%BB%A4%E9%95%9C%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[简述在这里记录下关于给图片添加滤镜的使用方法 查看滤镜种类123//获取滤镜种类 NSArray *filterNames = [CIFilter filterNamesInCategory:kCICategoryBuiltIn]; NSLog(@&quot;总共有%ld种滤镜效果:%@&quot;,filterNames.count,filterNames); 使用该方法可以获取苹果给的所有滤镜种类有180种 获取带滤镜效果的图片从上方获取想要的滤镜效果 也可以去官方文档查看 各种滤镜的总类效果http://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/filter/ci/ 获取带滤镜效果的图片方法如下: 以CIPhotoEffectTransfer为例 1234567891011121314151617181920212223242526/** 获取带滤镜的图片 @param filterName 滤镜效果名称 @param originImage 原始图 @return 带滤镜的图 */-(UIImage *)getFilterImageToUserFilterName:(NSString *)filterName andOriginImageName:(UIImage *)originImage&#123; CIImage *ciImage =[[CIImage alloc]initWithImage:originImage]; //CIFilter 滤镜 CIFilter *filter = [CIFilter filterWithName:filterName keysAndValues:kCIInputImageKey,ciImage,nil]; //使用默认参数 [filter setDefaults]; //生成上下文 CIContext *context =[CIContext contextWithOptions:nil]; //滤镜生成器输出图片 CIImage *outputImage =[filter outputImage]; //转换为UIImage CGImageRef cgImage =[context createCGImage:outputImage fromRect:[outputImage extent]]; UIImage *image =[UIImage imageWithCGImage:cgImage]; //释放 CGImageRelease(cgImage); return image;&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nohup进程后台运行、查看、终止]]></title>
    <url>%2F2018%2F03%2F05%2Fnohup%E8%BF%9B%E7%A8%8B%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E3%80%81%E6%9F%A5%E7%9C%8B%E3%80%81%E7%BB%88%E6%AD%A2%2F</url>
    <content type="text"><![CDATA[简述关于nohup和&amp;，进程后台运行、查看、终止 nohup和&amp;nohup 命令可以使命令永久的执行下去，和终端没有关系，退出终端也不会影响程序的运行；&amp; 是后台运行的意思，但当用户退出的时候，命令自动也跟着退出。那么，把两个结合起来nohup 命令 &amp;这样就能使命令永久的在后台执行在终端执行nohup 命令 &gt; output.log 2&gt;&amp;1 &amp;nohup+最后面的&amp;是让命令在后台执行 &gt;output.log是将信息输出到output.log日志中 2&gt;&amp;1是将标准错误信息转变成标准输出，这样就可以将错误信息输出到output.log 日志里面来。 查看日志tail -f output.log（动态显示） cat output.log（一次性显示整个文件） 查看当前Python进程ps -ef |grep python 杀死进程sudo kill 进程号 kill 9 进程号 #绝杀]]></content>
      <categories>
        <category>centos</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7 更新Firefox版本]]></title>
    <url>%2F2018%2F03%2F05%2Fcentos7-%E6%9B%B4%E6%96%B0Firefox%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[简述centos系统中，修改Firefox版本，改为Firefox 45.0版本 步骤1、因我的是centos 64位系统，选则下载安装包Firefox-latest-x86_64.tar.bz2 2、进入存放安装包的目录cd /var/temp 3、下载压缩包wget https://download-ssl.firefox.com.cn/releases/firefox/45.0/zh-CN/Firefox-latest-x86_64.tar.bz2 4、解压压缩包tar -xjvf Firefox-latest-x86_64.tar.bz2 5、删除旧版的firefox，通常在/usr/lib64目录下rm -rf /usr/lib64/firefox 6、将当前目录下的新版 firefox 子目录复制到/usr/lib64目录下mv firefox /usr/lib64 7、进入 /usr/bin 目录，删除其下的 firefox 脚本cd /usr/bin rm firefox 8、回到主目录或根目录，创建一个软链接，指向/usr/lib64/firefox/firefoxcd ~ ln -s /usr/lib64/firefox/firefox /usr/bin/firefox 9、查看下最新版本firefox -v]]></content>
      <categories>
        <category>centos</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tar: bzip2：无法 exec: 没有那个文件或目录]]></title>
    <url>%2F2018%2F03%2F05%2Ftar-bzip2%EF%BC%9A%E6%97%A0%E6%B3%95-exec-%E6%B2%A1%E6%9C%89%E9%82%A3%E4%B8%AA%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[问题centos系统中 tar指令打开压缩包报错tar: bzip2：无法 exec: 没有那个文件或目录、 解决系统中缺少bzip2包，执行以下指令yum install -y bzip2]]></content>
      <categories>
        <category>centos</category>
      </categories>
      <tags>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next主题去掉码云的Coding Pages等待跳转页面]]></title>
    <url>%2F2018%2F02%2F28%2FNext%E4%B8%BB%E9%A2%98%E5%8E%BB%E6%8E%89%E7%A0%81%E4%BA%91%E7%9A%84Coding-Pages%E7%AD%89%E5%BE%85%E8%B7%B3%E8%BD%AC%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[###简介Hexo Next静态博客挂在Coding Pages平台上，出现等待跳转页。看得有些烦，纪录下如何去除该界面的方法。(Next版本5.1.4) #####1、升级成银牌会员（必须）完善码云中的个人信息就好了，这是必要步骤 #####2、修改footer.swig文件找到next主题文件下的/themes/next/layout/_partials/footer.swig,找到该行,在第35行这里 1&lt;div class=&quot;theme-info&quot;&gt; 这里放着静态页面底部的一些主题信息，修改代码并添加一句 1&lt;p&gt;Hosted by &lt;a href=&quot;https://pages.coding.me&quot; style=&quot;font-weight: bold&quot;&gt;Coding Pages&lt;/a&gt;&lt;/p&gt; 最后完整的代码是: 12345678910111213&#123;% if theme.footer.powered and theme.footer.theme.enable %&#125; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125;&lt;div class=&quot;theme-info&quot;&gt; &lt;span&gt;Hosted by &lt;a href=&quot;https://pages.coding.me&quot; style=&quot;font-weight: bold&quot;&gt;Coding Pages&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;&#123;% if theme.footer.custom_text %&#125; &lt;div class=&quot;footer-custom&quot;&gt;&#123;# #&#125;&#123;&#123; theme.footer.custom_text &#125;&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125; 前往coding平台对应项目的pages服务页面，在最底部勾选已放置Hosted by Coding Pages选项，等待审核]]></content>
      <categories>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[检测用户截屏，并获取截取的图片]]></title>
    <url>%2F2018%2F02%2F26%2F%E6%A3%80%E6%B5%8B%E7%94%A8%E6%88%B7%E6%88%AA%E5%B1%8F%EF%BC%8C%E5%B9%B6%E8%8E%B7%E5%8F%96%E6%88%AA%E5%8F%96%E7%9A%84%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[记录下关于如何检测用户截屏行为（Home + Power），并获取截屏的图片。。。 注册通知iOS7后提供的一个推送方法UIApplicationUserDidTakeScreenshotNotification，在用户截屏完成后会得到一个通知12// This notification is posted after the user takes a screenshot (for example by pressing both the home and lock screen buttons)UIKIT_EXTERN NSNotificationName const UIApplicationUserDidTakeScreenshotNotification NS_AVAILABLE_IOS(7_0); 123[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(userDidTakeScreenshot:) name:UIApplicationUserDidTakeScreenshotNotification object:nil]; 获取图片123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//截屏响应-(void)userDidTakeScreenshot:(NSNotification *)notificationr&#123; NSLog(@&quot;检测到截屏&quot;); //获取图片，做你想做的事。。。。。。。 UIImage *img=[UIImage imageWithData:[self dataWithScreenshotInPNGFormat]];&#125;//截取当前屏幕-(NSData *)dataWithScreenshotInPNGFormat&#123; CGSize imageSize = CGSizeZero; UIInterfaceOrientation orientation = [UIApplication sharedApplication].statusBarOrientation; if (UIInterfaceOrientationIsPortrait(orientation)) imageSize = [UIScreen mainScreen].bounds.size; else imageSize = CGSizeMake([UIScreen mainScreen].bounds.size.height, [UIScreen mainScreen].bounds.size.width); UIGraphicsBeginImageContextWithOptions(imageSize, NO, [UIScreen mainScreen].scale); CGContextRef context = UIGraphicsGetCurrentContext(); for (UIWindow *window in [[UIApplication sharedApplication] windows]) &#123; CGContextSaveGState(context); CGContextTranslateCTM(context, window.center.x, window.center.y); CGContextConcatCTM(context, window.transform); CGContextTranslateCTM(context, -window.bounds.size.width * window.layer.anchorPoint.x, -window.bounds.size.height * window.layer.anchorPoint.y); if (orientation == UIInterfaceOrientationLandscapeLeft) &#123; CGContextRotateCTM(context, M_PI_2); CGContextTranslateCTM(context, 0, -imageSize.width); &#125; else if (orientation == UIInterfaceOrientationLandscapeRight) &#123; CGContextRotateCTM(context, -M_PI_2); CGContextTranslateCTM(context, -imageSize.height, 0); &#125; else if (orientation == UIInterfaceOrientationPortraitUpsideDown) &#123; CGContextRotateCTM(context, M_PI); CGContextTranslateCTM(context, -imageSize.width, -imageSize.height); &#125; if ([window respondsToSelector:@selector(drawViewHierarchyInRect:afterScreenUpdates:)]) &#123; [window drawViewHierarchyInRect:window.bounds afterScreenUpdates:YES]; &#125; else &#123; [window.layer renderInContext:context]; &#125; CGContextRestoreGState(context); &#125; UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return UIImagePNGRepresentation(image);&#125;//返回截取到的图片-(UIImage *)imageWithScreenshot&#123; NSData *imageData = [self dataWithScreenshotInPNGFormat]; return [UIImage imageWithData:imageData];&#125; 注销通知1234-(void)dealloc&#123; [[NSNotificationCenter defaultCenter]removeObserver:self];&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
</search>
